<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Assigned Quiz</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #f1f5f9;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      line-height: 1.6;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 24px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 28px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .title {
      display: flex;
      align-items: center;
      gap: 14px;
      font-weight: 700;
      font-size: 20px;
      letter-spacing: -0.02em;
    }

    .title .badge {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }

    .timer {
      font-weight: 800;
      color: #60a5fa;
      font-size: 24px;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.05em;
      text-shadow: 0 2px 8px rgba(96, 165, 250, 0.3);
    }

    .nav-actions {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .btn {
      padding: 12px 24px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.08);
      color: #f1f5f9;
      cursor: pointer;
      text-decoration: none;
      font-weight: 600;
      font-size: 15px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.25);
      transform: translateY(-1px);
    }

    .btn-primary {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      border: none;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }

    .card {
      background: rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 32px;
      margin-top: 24px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      transition: all 0.3s ease;
    }

    .hidden {
      display: none;
    }

    .notice {
      margin: 16px 0;
      color: #cbd5e1;
      font-size: 16px;
      line-height: 1.6;
    }

    .progress {
      font-weight: 700;
      margin-bottom: 20px;
      color: #60a5fa;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .question {
      font-size: 22px;
      font-weight: 700;
      margin: 20px 0 24px;
      line-height: 1.4;
      color: #f8fafc;
    }

    .option {
      margin: 12px 0;
      background: rgba(255, 255, 255, 0.04);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .option:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(59, 130, 246, 0.4);
      transform: translateX(4px);
    }

    .option label {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 16px;
      font-weight: 500;
    }

    .option input[type="radio"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: #3b82f6;
    }

    .option:has(input:checked) {
      background: rgba(59, 130, 246, 0.15);
      border-color: #3b82f6;
    }

    /* Camera monitoring box */
    .camera-monitor {
      margin: 20px 0;
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }

    .camera-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 12px;
      font-weight: 600;
      color: #60a5fa;
    }

    .camera-header .status-text {
      font-size: 14px;
    }

    .camera-status {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ef4444;
      animation: pulse 2s infinite;
    }

    .camera-status.active {
      background: #10b981;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .camera-container {
      position: relative;
      width: 100%;
      max-width: 300px;
      margin: 0 auto;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
    }

    .camera-video {
      width: 100%;
      height: 200px;
      object-fit: cover;
      display: block;
    }

    .camera-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .face-detection-box {
      position: absolute;
      border: 2px solid #3b82f6;
      background: rgba(59, 130, 246, 0.1);
      border-radius: 4px;
    }

    .eye-tracker {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
      animation: blink 1s infinite;
    }

    .eye-tracker.looking-up {
      background: #f59e0b;
    }

    .eye-tracker.looking-down {
      background: #ef4444;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .attention-warning {
      margin-top: 8px;
      padding: 8px 12px;
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 6px;
      color: #fca5a5;
      font-size: 14px;
      font-weight: 500;
      display: none;
    }

    .attention-warning.show {
      display: block;
    }

    .actions {
      display: flex;
      gap: 12px;
      margin-top: 28px;
      flex-wrap: wrap;
    }

    .result-list {
      margin: 20px 0 0;
    }

    #resultSummary {
      font-size: 20px;
      font-weight: 700;
      color: #60a5fa;
      margin-bottom: 16px;
    }

    #resultDetails ul {
      list-style: none;
      padding: 0;
    }

    #resultDetails li {
      padding: 12px 16px;
      margin: 8px 0;
      background: rgba(239, 68, 68, 0.1);
      border-left: 3px solid #ef4444;
      border-radius: 8px;
      font-size: 14px;
      color: #fca5a5;
    }

    #quizMsg {
      color: #fbbf24;
      font-weight: 600;
      margin-top: 12px;
    }

    @media (max-width: 640px) {
      .container {
        padding: 24px 16px;
      }

      .header {
        flex-direction: column;
        gap: 16px;
        text-align: center;
      }

      .title {
        font-size: 18px;
      }

      .timer {
        font-size: 20px;
      }

      .card {
        padding: 24px 20px;
      }

      .question {
        font-size: 18px;
      }

      .actions {
        flex-direction: column;
      }

      .btn {
        width: 100%;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title"><div class="badge">✈</div><div>Assigned Quiz</div></div>
      <div class="nav-actions">
        <a class="btn" href="/home">Home</a>
        <div class="timer" id="timer">--:--</div>
      </div>
    </div>
    <div id="setupCard" class="card">
      <div class="notice" id="setupMsg">This quiz was assigned to you. When you click Start, the timer begins.</div>
      <div class="actions">
        <button class="btn btn-primary" id="startAssigned">Start Quiz</button>
        <a class="btn" href="/home">Back</a>
      </div>
    </div>

    <div id="quizCard" class="card hidden">
      <div id="progress"></div>
      <div id="questionText" style="margin: 12px 0;"></div>
      <div id="options"></div>
      
      <!-- Camera monitoring box -->
      <div class="camera-monitor">
        <div class="camera-header">
          <div class="camera-status" id="cameraStatus"></div>
          <span class="status-text">Seat Detection Monitoring</span>
        </div>
        <div class="camera-container">
          <video id="cameraVideo" class="camera-video" autoplay muted playsinline></video>
          <div class="camera-overlay" id="cameraOverlay"></div>
        </div>
        <div class="attention-warning" id="attentionWarning">
          ⚠️ Please remain seated during the exam.
        </div>
      </div>
      
      <div class="actions">
        <button class="btn" id="nextBtn">Next</button>
        <button class="btn btn-primary hidden" id="submitBtn">Submit</button>
        <button class="btn" id="cancelBtn">Cancel</button>
      </div>
      <div id="quizMsg" class="notice"></div>
    </div>

    <div id="resultCard" class="card hidden">
      <div id="resultSummary"></div>
      <div id="resultDetails" style="margin-top:8px;"></div>
      <div class="actions">
        <a class="btn" href="/home">Home</a>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const qs = new URLSearchParams(window.location.search);
      let assignmentId = qs.get('assignment_id');
      const setupCard = document.getElementById('setupCard');
      const quizCard = document.getElementById('quizCard');
      const resultCard = document.getElementById('resultCard');
      const setupMsg = document.getElementById('setupMsg');
      const startBtn = document.getElementById('startAssigned');
      const progressEl = document.getElementById('progress');
      const questionTextEl = document.getElementById('questionText');
      const optionsEl = document.getElementById('options');
      const nextBtn = document.getElementById('nextBtn');
      const submitBtn = document.getElementById('submitBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      const quizMsg = document.getElementById('quizMsg');
      const resultSummary = document.getElementById('resultSummary');
      const resultDetails = document.getElementById('resultDetails');
      const timerEl = document.getElementById('timer');
      
      // Camera monitoring elements
      const cameraVideo = document.getElementById('cameraVideo');
      const cameraStatus = document.getElementById('cameraStatus');
      const cameraOverlay = document.getElementById('cameraOverlay');
      const attentionWarning = document.getElementById('attentionWarning');

      const state = { 
        questions: [], 
        index: 0, 
        answers: {}, 
        countdown: 0, 
        tick: null, 
        started: false, 
        initializing: false, 
        inQuiz: false, 
        cameraActive: false, 
        attentionScore: 0,
        faceDetectionActive: false,
        lastFaceDetected: null,
        noFaceTimer: null,
        faceDetectionInterval: null
      };

      function show(el){ el.classList.remove('hidden'); }
      function hide(el){ el.classList.add('hidden'); }
      function setMsg(el, t){ el.textContent = t || ''; }

      // Persist/restore quiz progress across refreshes (per assignment)
      function storageKey(){ return assignmentId ? `assigned_quiz_state_${assignmentId}` : null; }
      function savePersisted(){
        const k = storageKey();
        if (!k) return;
        const payload = { 
          index: state.index, 
          answers: state.answers, 
          countdown: state.countdown, 
          started: state.started,
          lastFaceDetected: state.lastFaceDetected
        };
        try { localStorage.setItem(k, JSON.stringify(payload)); } catch(_) {}
      }
      function loadPersisted(){
        const k = storageKey();
        if (!k) return null;
        try { const raw = localStorage.getItem(k); return raw ? JSON.parse(raw) : null; } catch(_) { return null; }
      }
      function clearPersisted(){
        const k = storageKey();
        if (!k) return;
        try { localStorage.removeItem(k); } catch(_) {}
      }

      function fmt(sec){ const m = Math.floor(sec/60); const s = sec%60; return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }
      function updateTimer(){ timerEl.textContent = fmt(state.countdown); }
      function timeOver(){
        if (state.tick){ clearInterval(state.tick); state.tick = null; }
        setMsg(setupMsg, 'Time is over for this quiz.');
        hide(quizCard); show(setupCard);
      }
      function startTimer(){
        if (state.tick) return;
        if (state.countdown <= 0){ timeOver(); return; }
        updateTimer();
        state.tick = setInterval(()=>{
          state.countdown -= 1;
          if (state.countdown < 0) state.countdown = 0;
          updateTimer();
          if (state.countdown <= 0){ clearInterval(state.tick); state.tick=null; submit(true); }
          // Save timer state every second
          savePersisted();
        }, 1000);
      }

      async function fetchQuestions(){
        try {
          const r = await fetch('/api/quiz-assignments/questions', { method:'POST', headers:{'Content-Type':'application/json'}, credentials:'include', body: JSON.stringify({ assignment_id: assignmentId }) });
          if (r.status === 401){ window.location.href = '/login.html'; return false; }
          if (r.status === 410){ setMsg(setupMsg, 'Time is over for this quiz.'); return false; }
          if (!r.ok){ setMsg(setupMsg, 'Failed to load assigned quiz.'); return false; }
          const d = await r.json();
          const cats = (d.quiz_data && Array.isArray(d.quiz_data.categories)) ? d.quiz_data.categories : [];
          const qs = cats.length ? (cats[0].questions || []) : [];
          state.questions = qs;
          return true;
        } catch(e){ setMsg(setupMsg, String(e)); return false; }
      }

      // Check if face setup is required
      async function checkFaceSetupRequired() {
        try {
          const response = await fetch('/api/check-face-setup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ assignment_id: assignmentId })
          });
          
          if (response.ok) {
            const result = await response.json();
            if (!result.face_setup_complete) {
              // Redirect to face setup
              window.location.href = `/quiz_setup.html?assignment_id=${assignmentId}`;
              return false;
            }
            return true;
          }
          return true; // Assume setup is complete if check fails
        } catch (e) {
          console.warn('Face setup check failed:', e);
          return true; // Assume setup is complete if check fails
        }
      }

      async function syncStatus(){
        try{
          const r = await fetch('/api/quiz-assignments/status', { method:'POST', headers:{'Content-Type':'application/json'}, credentials:'include', body: JSON.stringify({ assignment_id: assignmentId }) });
          if (r.status === 401){ window.location.href = '/login.html'; return false; }
          if (!r.ok){ return false; }
          const d = await r.json();
          if (d.finished){ setMsg(setupMsg, 'Time is over for this quiz.'); hide(quizCard); show(setupCard); return false; }
          const rem = parseInt(d.remaining_seconds||0,10);
          const dur = parseInt(d.duration_seconds||900,10);
          state.countdown = Math.max(0, Math.min(rem, dur));
          state.started = !!d.started;
          updateTimer();
          return true;
        }catch(_){ return false; }
      }

      async function resolveAssignmentIfMissing(){
        if (assignmentId) return true;
        try{
          const r = await fetch('/api/my/assignments', { credentials:'include' });
          if (!r.ok) { setMsg(setupMsg, 'Missing assignment_id. No assigned quiz found.'); startBtn.disabled = true; return false; }
          const list = await r.json();
          const open = Array.isArray(list) ? list.find(a => !a.finished_at) : null;
          if (!open){ setMsg(setupMsg, 'No assigned quiz available.'); startBtn.disabled = true; return false; }
          assignmentId = open.assignment_id || open._id || open.id; // prefer explicit assignment_id
          if (!assignmentId){ setMsg(setupMsg, 'Could not determine assignment.'); startBtn.disabled = true; return false; }
          const url = new URL(window.location.href);
          url.searchParams.set('assignment_id', assignmentId);
          window.history.replaceState({}, '', url.toString());
          setMsg(setupMsg, 'Quiz ready. Click Start to begin.');
          return true;
        } catch(e){ setMsg(setupMsg, 'Missing assignment_id.'); return false; }
      }

      function render(){
        const i = state.index;
        const q = state.questions[i];
        progressEl.textContent = `Question ${i+1} of ${state.questions.length}`;
        questionTextEl.textContent = q.question || '';
        optionsEl.innerHTML = '';
        Object.entries(q.options||{}).sort((a,b)=>a[0].localeCompare(b[0])).forEach(([k,label])=>{
          const div = document.createElement('div');
          div.className = 'option';
          div.innerHTML = `<label><input type="radio" name="q_${i}" value="${k}"> ${k}. ${label}</label>`;
          optionsEl.appendChild(div);
        });
        // Restore previous selection for this question, if any
        const saved = state.answers[i];
        if (saved){
          const el = optionsEl.querySelector(`input[name="q_${i}"][value="${saved}"]`);
          if (el) { el.checked = true; }
        }
        setMsg(quizMsg, '');
        if (i === state.questions.length-1){ hide(nextBtn); show(submitBtn); } else { show(nextBtn); hide(submitBtn); }
      }

      function recordOrWarn(){
        const i = state.index;
        const sel = document.querySelector(`input[name="q_${i}"]:checked`);
        if (!sel){ setMsg(quizMsg, 'Please select an answer.'); return false; }
        state.answers[i] = sel.value;
        savePersisted();
        return true;
      }

      function next(){ if (!recordOrWarn()) return; if (state.index < state.questions.length-1){ state.index += 1; savePersisted(); render(); } }
      function cancel(){ hide(quizCard); hide(resultCard); show(setupCard); if (state.tick){ clearInterval(state.tick); state.tick=null; } stopCamera(); clearPersisted(); state.inQuiz = false; setMsg(setupMsg, 'Quiz cancelled.'); }

      function submit(auto=false){ if (!recordOrWarn()) return; if (state.tick){ clearInterval(state.tick); state.tick=null; }
        let score=0, total=0; const details=[]; state.questions.forEach((q, i)=>{
          const ans = String(state.answers[i]||'').toUpperCase();
          const key = (q.correct_answer==null)?null:String(q.correct_answer).toUpperCase();
          if (key==null) return; total+=1; if (ans===key) score+=1; else details.push(`Q${i+1} (${q.id||i}): Your ${ans} | Correct ${key}`);
        });
        resultSummary.textContent = `Attempted: ${state.questions.length} — Score: ${score}/${total}`;
        const answeredCount = Object.keys(state.answers).length;
        const allAnswered = answeredCount === state.questions.length;
        const summaryLine = `<div><strong>Summary:</strong> ${allAnswered ? 'All questions answered.' : `Answered ${answeredCount}/${state.questions.length}.`}</div>`;
        const listHtml = details.length? `<ul>${details.map(t=>`<li>${t}</li>`).join('')}</ul>` : '';
        resultDetails.innerHTML = summaryLine + listHtml;
        const answers = state.questions.map((q, i)=>({ id: (q.id!=null?q.id:i), section: q._section||null, your: String(state.answers[i]||'').toUpperCase(), correct: (q.correct_answer==null?null:String(q.correct_answer).toUpperCase()) }));
        fetch('/api/scores', { method:'POST', headers:{'Content-Type':'application/json'}, credentials:'include', body: JSON.stringify({ attempted: state.questions.length, correct: score, total_with_keys: total, assignment_id: assignmentId, answers }) }).catch(()=>{});
        hide(quizCard); show(resultCard);
        clearPersisted();
        stopCamera();
        state.inQuiz = false;
        try { alert('Good luck with check'); } catch(_) {}
      }

      // Check if quiz was terminated due to violation
      function checkTerminationStatus() {
        const k = storageKey();
        if (k) {
          try {
            const terminated = localStorage.getItem(`${k}_terminated`);
            if (terminated) {
              const data = JSON.parse(terminated);
              if (data.terminated) {
                setMsg(setupMsg, `Quiz terminated due to violation: ${data.message}`);
                startBtn.disabled = true;
                startBtn.textContent = 'Quiz Terminated';
                return true;
              }
            }
          } catch(_) {}
        }
        return false;
      }

      // Initial state
      if (!assignmentId){ setMsg(setupMsg, 'Looking for your assigned quiz...'); }
      
      // Check termination status first
      if (checkTerminationStatus()) {
        // Quiz was terminated, don't proceed with normal flow
        return;
      }

      // Wire events
      startBtn.addEventListener('click', async ()=>{
        if (state.initializing || state.inQuiz) return;
        state.initializing = true;
        const resolved = await resolveAssignmentIfMissing();
        if (!resolved) { state.initializing = false; return; }
        
        // Check if face setup is required
        const faceSetupComplete = await checkFaceSetupRequired();
        if (!faceSetupComplete) { 
          state.initializing = false; 
          return; 
        }
        
        // Start the quiz directly since we came from setup
        startQuiz();
        state.initializing = false;
      });
      nextBtn.addEventListener('click', next);
      submitBtn.addEventListener('click', submit);
      cancelBtn.addEventListener('click', cancel);

      // Auto-resume: if quiz already started, continue with remaining time and progress
      (async ()=>{
        if (state.initializing || state.inQuiz) return;
        updateTimer();
        const have = assignmentId ? true : await resolveAssignmentIfMissing();
        if (!have) return;
        const ok = await syncStatus();
        if (ok && state.started){
          const got = await fetchQuestions();
          if (got){
            const persisted = loadPersisted();
            if (persisted && typeof persisted.index === 'number' && persisted.answers){
              state.index = Math.min(Math.max(0, persisted.index), Math.max(0, state.questions.length-1));
              state.answers = persisted.answers || {};
              // Restore timer if available and valid
              if (typeof persisted.countdown === 'number' && persisted.countdown > 0) {
                state.countdown = persisted.countdown;
                state.started = !!persisted.started;
              }
            }
            if (state.countdown <= 0){
              setMsg(setupMsg, 'Time is over for this quiz.');
              return;
            }
            hide(setupCard); show(quizCard); render(); 
            // Initialize camera monitoring
            initCamera();
            startTimer();
            state.inQuiz = true;
          }
        }
      })();

      // Auto-start if coming from quiz setup (no persisted state)
      (async ()=>{
        if (state.initializing || state.inQuiz) return;
        const have = assignmentId ? true : await resolveAssignmentIfMissing();
        if (!have) return;
        
        // Check if we have a fresh assignment (no persisted state)
        const persisted = loadPersisted();
        if (!persisted) {
          const ok = await syncStatus();
          if (ok && state.countdown > 0) {
            const got = await fetchQuestions();
            if (got) {
              state.index = 0;
              state.answers = {};
              state.started = true;
              savePersisted();
              
              hide(setupCard); show(quizCard); render();
              // Initialize camera monitoring
              initCamera();
              startTimer();
              state.inQuiz = true;
            }
          }
        }
      })();

      // Camera monitoring functions for seat detection and face detection
      async function initCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              width: { ideal: 640 }, 
              height: { ideal: 480 },
              facingMode: 'user'
            } 
          });
          cameraVideo.srcObject = stream;
          cameraStatus.classList.add('active');
          state.cameraActive = true;
          startSeatDetection();
          startFaceDetection();
        } catch (error) {
          console.warn('Camera access denied:', error);
          cameraStatus.style.background = '#f59e0b';
          attentionWarning.textContent = '⚠️ Camera access required for seat monitoring.';
          attentionWarning.classList.add('show');
        }
      }

      function startSeatDetection() {
        if (!state.cameraActive) return;
        
        let baselineFrame = null;
        let seatViolations = 0;
        let lastViolationTime = 0;
        let consecutiveMovementFrames = 0;
        const violationThreshold = 3; // Number of violations before warning
        const violationCooldown = 5000; // 5 seconds between violation checks
        const movementThreshold = 0.15; // Movement sensitivity
        const consecutiveThreshold = 3; // Consecutive frames with movement
        
        const detectSeatMovement = () => {
          if (!state.cameraActive) return;
          
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = cameraVideo.videoWidth || 320;
            canvas.height = cameraVideo.videoHeight || 240;
            
            ctx.drawImage(cameraVideo, 0, 0, canvas.width, canvas.height);
            const currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            if (baselineFrame === null) {
              // Set baseline frame after 2 seconds
              setTimeout(() => {
                baselineFrame = currentFrame;
              }, 2000);
              setTimeout(detectSeatMovement, 1000);
              return;
            }
            
            // Compare current frame with baseline to detect movement
            const movement = compareFrames(baselineFrame, currentFrame);
          const now = Date.now();
            
            // Track consecutive movement frames
            if (movement > movementThreshold) {
              consecutiveMovementFrames++;
            } else {
              consecutiveMovementFrames = 0;
            }
            
            // Trigger violation if consecutive movement detected
            if (consecutiveMovementFrames >= consecutiveThreshold && now - lastViolationTime > violationCooldown) {
              seatViolations++;
              lastViolationTime = now;
              consecutiveMovementFrames = 0; // Reset counter
              
              // Show warning if too many violations
              if (seatViolations >= violationThreshold) {
                attentionWarning.textContent = '⚠️ Significant movement detected! Please remain seated during the exam.';
              attentionWarning.classList.add('show');
                
                // Log violation to server (best effort)
                fetch('/api/log-violation', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  credentials: 'include',
                  body: JSON.stringify({ 
                    assignment_id: assignmentId,
                    type: 'seat_movement',
                    timestamp: new Date().toISOString(),
                    message: 'Significant movement detected - possible standing up',
                    movement_level: movement
                  })
                }).catch(() => {});
              }
              
              // Visual indicator
              const movementIndicator = document.createElement('div');
              movementIndicator.style.cssText = `
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(239, 68, 68, 0.9);
                color: white;
                padding: 6px 12px;
                border-radius: 6px;
                font-size: 14px;
                font-weight: bold;
                z-index: 1000;
              `;
              movementIndicator.textContent = 'MOVEMENT DETECTED';
              cameraOverlay.appendChild(movementIndicator);
            
            setTimeout(() => {
                if (movementIndicator.parentNode) {
                  movementIndicator.parentNode.removeChild(movementIndicator);
                }
              }, 3000);
            } else if (movement < 0.05) {
              // Reset violations if candidate is seated properly
              if (seatViolations > 0) {
                seatViolations = Math.max(0, seatViolations - 1);
                if (seatViolations === 0) {
                  attentionWarning.classList.remove('show');
                }
              }
            }
            
            // Update baseline frame periodically to adapt to lighting changes
            if (Math.random() < 0.1) { // 10% chance to update baseline
              baselineFrame = currentFrame;
            }
            
            setTimeout(detectSeatMovement, 1000);
          } catch (error) {
            console.warn('Seat detection error:', error);
            setTimeout(detectSeatMovement, 2000);
          }
        };
        
        detectSeatMovement();
      }
      
      function compareFrames(frame1, frame2) {
        if (!frame1 || !frame2) return 0;
        
        const data1 = frame1.data;
        const data2 = frame2.data;
        let diff = 0;
        let pixelCount = 0;
        const sampleRate = 2; // Sample every 2nd pixel for better accuracy
        
        // Calculate difference for each sampled pixel
        for (let i = 0; i < data1.length; i += sampleRate * 4) {
          const r1 = data1[i];
          const g1 = data1[i + 1];
          const b1 = data1[i + 2];
          const r2 = data2[i];
          const g2 = data2[i + 1];
          const b2 = data2[i + 2];
          
          // Calculate Euclidean distance in RGB space
          const rDiff = r1 - r2;
          const gDiff = g1 - g2;
          const bDiff = b1 - b2;
          const pixelDiff = Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
          
          diff += pixelDiff;
          pixelCount++;
        }
        
        // Normalize to 0-1 range (max possible diff is sqrt(3 * 255^2) ≈ 441)
        return diff / (pixelCount * 441);
      }

      function startFaceDetection() {
        if (!state.cameraActive) return;
        
        state.faceDetectionActive = true;
        state.lastFaceDetected = Date.now();
        
        // Check for faces every 2 seconds
        state.faceDetectionInterval = setInterval(async () => {
          if (!state.faceDetectionActive) return;
          
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = cameraVideo.videoWidth || 320;
            canvas.height = cameraVideo.videoHeight || 240;
            
            ctx.drawImage(cameraVideo, 0, 0, canvas.width, canvas.height);
            const imageData = canvas.toDataURL('image/jpeg');
            
            // Send frame to backend for face detection
            const response = await fetch('/api/check-frame', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({ 
                image: imageData,
                assignment_id: assignmentId
              })
            });
            
            if (response.ok) {
              const result = await response.json();
              updateFaceStatus(result.faces_detected);
              
              if (result.faces_detected > 0) {
                state.lastFaceDetected = Date.now();
                // Clear any existing no-face timer
                if (state.noFaceTimer) {
                  clearTimeout(state.noFaceTimer);
                  state.noFaceTimer = null;
                }
              } else {
                // No face detected - start 30 second countdown
                if (!state.noFaceTimer) {
                  state.noFaceTimer = setTimeout(() => {
                    handleNoFaceViolation();
                  }, 30000); // 30 seconds
                }
              }
              
              // Handle alerts from backend
              if (result.alerts && result.alerts.length > 0) {
                result.alerts.forEach(alert => {
                  // Check if this is a critical violation that should terminate the quiz
                  if (alert.severity === 'critical' || alert.type === 'MULTIPLE_FACES' || alert.type === 'FACE_MISMATCH') {
                    handleViolation(alert.type.toLowerCase(), alert.message);
                    return; // Stop processing other alerts
                  } else {
                    showAlert(alert.message, alert.severity);
                  }
                });
              }
            }
          } catch (error) {
            console.warn('Face detection error:', error);
              }
            }, 2000);
      }
      
      function updateFaceStatus(faceCount) {
        const statusElement = document.querySelector('.status-text');
        if (faceCount === 0) {
          cameraStatus.style.background = '#ef4444';
          if (statusElement) statusElement.textContent = 'No Face Detected';
        } else if (faceCount === 1) {
          cameraStatus.style.background = '#10b981';
          if (statusElement) statusElement.textContent = 'Face Detected';
          } else {
          cameraStatus.style.background = '#f59e0b';
          if (statusElement) statusElement.textContent = 'Multiple Faces';
        }
      }
      
      function handleNoFaceViolation() {
        // Capture image before termination
        captureViolationImage('no_face_detected', 'No face detected for 30 seconds');
      }
      
      function handleViolation(violationType, message) {
        // Capture image before termination
        captureViolationImage(violationType, message);
      }
      
      function captureViolationImage(violationType, message) {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = cameraVideo.videoWidth || 320;
          canvas.height = cameraVideo.videoHeight || 240;
          
          ctx.drawImage(cameraVideo, 0, 0, canvas.width, canvas.height);
          const imageData = canvas.toDataURL('image/jpeg');
          
          // Send violation with captured image to server
          fetch('/api/log-violation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ 
              assignment_id: assignmentId,
              type: violationType,
              timestamp: new Date().toISOString(),
              message: message,
              captured_image: imageData
            })
          }).then(() => {
            // Terminate quiz after logging violation
            terminateQuiz(violationType, message);
          }).catch(() => {
            // Still terminate even if logging fails
            terminateQuiz(violationType, message);
          });
        } catch (error) {
          console.error('Error capturing violation image:', error);
          // Still terminate even if capture fails
          terminateQuiz(violationType, message);
        }
      }
      
      function terminateQuiz(violationType, message) {
        // Stop all monitoring
        if (state.tick) {
          clearInterval(state.tick);
          state.tick = null;
        }
        if (state.faceDetectionInterval) {
          clearInterval(state.faceDetectionInterval);
          state.faceDetectionInterval = null;
        }
        if (state.noFaceTimer) {
          clearTimeout(state.noFaceTimer);
          state.noFaceTimer = null;
        }
        
        // Stop camera
        stopCamera();
        
        // Mark quiz as terminated in localStorage
        const k = storageKey();
        if (k) {
          try {
            localStorage.setItem(`${k}_terminated`, JSON.stringify({
              terminated: true,
              violationType: violationType,
              message: message,
              timestamp: new Date().toISOString()
            }));
          } catch(_) {}
        }
        
        // Clear persisted state
        clearPersisted();
        
        // Hide quiz interface
        hide(quizCard);
        
        // Show rejection modal
        showRejectionModal(violationType, message);
      }
      
      function showRejectionModal(violationType, message) {
        // Create rejection modal
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;
        
        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
          background: #1e293b;
          border: 2px solid #ef4444;
          border-radius: 16px;
          padding: 32px;
          max-width: 500px;
          width: 90%;
          text-align: center;
          color: #f1f5f9;
        `;
        
        const violationMessages = {
          'no_face_detected': 'No face detected for 30 seconds',
          'multiple_faces': 'Multiple faces detected',
          'position_change': 'Significant position change detected',
          'distance_change': 'Distance from camera changed significantly',
          'face_mismatch': 'Different person detected',
          'no_eyes': 'Eyes not detected - face may be obscured',
          'multiple_eyes': 'Multiple eye pairs detected'
        };
        
        const violationTitle = violationMessages[violationType] || message;
        
        modalContent.innerHTML = `
          <div style="font-size: 48px; margin-bottom: 16px;">❌</div>
          <h2 style="color: #ef4444; margin-bottom: 16px; font-size: 24px;">Quiz Terminated</h2>
          <p style="margin-bottom: 24px; font-size: 18px; color: #cbd5e1;">Sorry, you have been rejected</p>
          <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; padding: 16px; margin-bottom: 24px;">
            <h3 style="color: #fca5a5; margin-bottom: 8px;">Violation Detected:</h3>
            <p style="color: #fca5a5; font-weight: 600;">${violationTitle}</p>
          </div>
          <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; padding: 16px; margin-bottom: 24px;">
            <h3 style="color: #fca5a5; margin-bottom: 8px;">⚠️ Access Blocked:</h3>
            <p style="color: #fca5a5; font-size: 14px;">You cannot access this quiz anymore due to the violation. The quiz has been permanently terminated.</p>
          </div>
          <p style="margin-bottom: 24px; color: #94a3b8; font-size: 14px;">
            A screenshot was captured at the time of violation for review purposes.
          </p>
          <button onclick="window.location.href='/home'" style="
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          " onmouseover="this.style.transform='translateY(-1px)'" onmouseout="this.style.transform='translateY(0)'">
            Return to Home
          </button>
        `;
        
        modal.appendChild(modalContent);
        document.body.appendChild(modal);
        
        // Prevent closing the modal
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }
      
      function showAlert(message, severity) {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert-item ${severity}`;
        
        const time = new Date().toLocaleTimeString();
        alertDiv.innerHTML = `
          <div class="alert-message">${message}</div>
          <div class="alert-time">${time}</div>
        `;
        
        // Add to a dedicated alerts area or show as overlay
        const alertOverlay = document.createElement('div');
        alertOverlay.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          border-left: 4px solid ${severity === 'critical' ? '#ef4444' : severity === 'high' ? '#f59e0b' : '#3b82f6'};
          font-size: 14px;
          z-index: 10000;
          max-width: 300px;
        `;
        alertOverlay.innerHTML = `<div>${message}</div><div style="font-size: 12px; opacity: 0.7;">${time}</div>`;
        
        document.body.appendChild(alertOverlay);
        
        setTimeout(() => {
          if (alertOverlay.parentNode) {
            alertOverlay.parentNode.removeChild(alertOverlay);
          }
        }, 5000);
      }

      function stopCamera() {
        if (cameraVideo.srcObject) {
          const tracks = cameraVideo.srcObject.getTracks();
          tracks.forEach(track => track.stop());
          cameraVideo.srcObject = null;
        }
        cameraStatus.classList.remove('active');
        state.cameraActive = false;
        state.faceDetectionActive = false;
        
        // Clear face detection interval
        if (state.faceDetectionInterval) {
          clearInterval(state.faceDetectionInterval);
          state.faceDetectionInterval = null;
        }
        
        // Clear no-face timer
        if (state.noFaceTimer) {
          clearTimeout(state.noFaceTimer);
          state.noFaceTimer = null;
        }
        
        cameraOverlay.innerHTML = '';
        attentionWarning.classList.remove('show');
      }

      // Persist on unload as a safeguard
      window.addEventListener('beforeunload', savePersisted);
    })();
  </script>
</body>
</html>
